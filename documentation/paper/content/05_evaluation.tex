\chapter{Evaluation}
\label{cha:evaluation}

Blockchain-Identity is a prototype implementation of a GDPR complaint solution of self-sovereign identity management in the blockchain. Since this project is more a proof-of-concept then a working platform, we will do a critical review of the implementation and concept section and outline the building blocks for future work.  

\section{Core-Logic}
\label{sec:coreLogicEval}
Since the whole system is a prototype there are several improvements that could increase security and stability in the proposed system. 

\subsection{Decentralized untrusted system}
\label{sec:untrustedSystem}
If we drop the principle of a private blockchain and let every provider write to the blockchain as well, we deescalate the government as single point of failure. To ensure further availability we could drop the discovery service and organize the discovery of an specific provider in a distributed hash table. Since we want still off-blockchain communication we could think about a peer-to-peer implementation which will completely decentralize the system. The final problem that still remains is how to establish trust in a new user without having the government as trusted party? Since we already considered the eID of the German government as a verification mechanism we can take this to the next level by allowing the peers to retrieve identity information from the eID directly. By doing so we would finally eliminate the government as needed, trusted party and can relay only heavily on the trust already established in the certificate which signed eID of the user\footnote{Of cause this certificate is still generated by the government but the government as such would be eliminated as central component where requests would be routed thou.}.

In such an untrusted system we need somehow verify the integrity of claims that are shared between providers. Here we can use the fact that the user is holding his own claims in his local database. On approving a permission contract he can send off-blockchain a preimage of his claims to the provider requesting the claims, to ensure that the claim holder does not tamper the claims when providing them to the requesting provider. However, since the provider itself is untrusted he may try to bruteforce the preimage of the claims of the user and will likely succeed if the hash is, for example, build over a boolean claim value. So we need to introduce a very strong salt. Using SHA-256 to produce a 256 bit long preimage, a salt needs to be securely generated that is at least bigger then 256 bits to ensure with 100\% certainty that a hash collision would exist\footnote{For more information about hash collisions refer to the so called “birthday attack” (\url{https://en.wikipedia.org/wiki/Birthday_attack}).}. The implications are that even if a hash collision would be found by a malicious provider he has only a 50\% probability to hit the right boolean value. So basically he knows nothing. To now ensure that the provider can only check the integrity of the user claims on retrieving the actual user claims, the user would encrypt the generated salt symmetrically with a shared secret, shared between user and requesting provider, and then again encrypt the salt again asymmetrically with the public key of the provider that holds the claims. The requesting provider needs the help of the claim holder provider to decrypt the symmetrically encrypted salt and can then proceed by decrypting the salt with the shared secret between provider and user. By doing so we would additionally ensure that the claim holder provider can not craft a hash collision salt and return the provider his salt with a faked claim value.  The requesting provider can now use the plain salt to verify the hash over the boolean claim.

An completely untrusted system comes also with other drawbacks. We need to somehow enforce fairness and balance. Fairness ensures that if a provider requests claims from another provider it is somehow guaranteed that he either retrieves the claims or an equivalent amount of money. Balance would mean that requesting claims comes along with cost that the requester needs to pay. Indeed ethereum is providing us with smart-contracts that can ensure this principles. However, GDPR is restricting us from saving either hashes nor encrypted claims in the blockchain, since if the key or the hashed preimage gets leaked, no one can remove this claims from the blockchain. 

We should also think about how the “right to be forgotten” will be enforced. Of course we can simply introduce do this manual by writing an email to the claim holder, but this is not the desired solution. It is a tricky point, since once a claim is shared, it can’t be simply revoked. We didn’t managed to find a suitable solution for this problem.  

\subsection{Closures are dangerous}
Remember that closures are boolean expressions build on a claim value a logical comparator and a static value that is used to compare it to the claim value. Closures shell not expose the claim value. But this is not always the case. Closures are only hiding the claim value if the closure result is unlinkable to the used claim value. However, building closure expressions over binary claim values and using the equals (EQ) or not equals (NEQ) operator will expose the claim value. A simple example is building a closure over the sex of a user: “SEX EQ ‘male’”. A provider can now use the closure result to relate it to the claim value of the user. If it evaluates to “true” the sex of the user is “male”, else it is “female”. We might also EQ to guess claims of the user. Whenever EQ is used and the closure evaluates to “true”, the claim value of the user is exposed. We so should only allow operators that relate to a higher anonymity set then 2. Sadly we do not know which claims are “secure” to be used in closures and which are not, since also number or string values may only consist of binary values. 

\subsection{Security evaluation}
\label{sec:securityEvaluation}
To recap the security goals we managed to implement authenticity by appending a signature on each request. Integrity is missing since the user service is not yet sending a hash over his claims to the provider requesting his claims to ensure that the claims from the government are the same the user holds. Non-repudiation and accountability is ensured by populating each transaction trough the blockchain as well as attaching signatures to responses (e.g. claims or closures). We are privacy preserving in a pseudonym fashion were each user is identifiable by his unique ethereum address. The encrypting process of closure is also providing perfect forward secrecy were the session is a one-time session key and so never used again. However, we do not provide a mechanism of key change/key recovery of the RSA key-pair. A missing security goal is confidentiality since the communication between provider is not secured. TLS/SSL would help here to easily secure the communication. 

\subsection{Summary}
The proposed backend is a proof-of-concept that identity in the blockchain can work even with law enforcements like GDPR. Still there are some improvements that could take into account when implementing the next version of this project. However, the proposed backend still offers some advantages that would be lost on completely decentralizing the system. The discovery service, as untrusted message broker and public key directory, is a simple and efficient solution to an peer-to-peer adaption of a client-server architecture. Further, we can simply trust each entry that comes from the government, since it is a trusted entity itself. This would not be possible in a complete untrusted system, where each request needs to validated by the user. Such an decentralized system would also have a hard time not to store hashes over claims in the blockchain to validate claim values, since each other location or transmission would not be tamper proof. 
